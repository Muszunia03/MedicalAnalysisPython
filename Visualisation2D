import nibabel as nib
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.colors import Normalize
from matplotlib import cm

# Function to display slices of a 4D or 3D volume interactively with grayscale + heatmap overlay
def display_interactive_slices_multichannel(volume, overlay=None):
    """
    Displays slices of a 3D or 4D volume interactively, with an optional heatmap overlay.
    
    Args:
        volume (numpy.ndarray): 3D or 4D volume to visualize (grayscale background).
        overlay (numpy.ndarray): Optional 3D or 4D volume to overlay as a heatmap.
    """
    # Check if volume is 3D or 4D
    is_4d = volume.ndim == 4
    num_slices = volume.shape[2]  # Number of slices along the Z-axis
    num_channels = volume.shape[3] if is_4d else 1  # Channels if 4D, otherwise 1
    current_slice = num_slices // 2  # Start at the middle slice

    # Check if overlay is provided and matches the volume shape
    has_overlay = overlay is not None
    if has_overlay and overlay.shape[:3] != volume.shape[:3]:
        raise ValueError("Overlay dimensions must match the volume dimensions (X, Y, Z).")

    # Set up subplots
    if num_channels > 1:
        fig, axes = plt.subplots(1, num_channels, figsize=(15, 5))
    else:
        fig, ax = plt.subplots(1, 1, figsize=(5, 5))
        axes = [ax]  # Wrap single axis in a list for consistency

    img_displays = []

    # Initialize the plots for each channel
    for i in range(num_channels):
        title = f'Channel {i + 1}, Slice {current_slice + 1}/{num_slices}' if is_4d else f'Slice {current_slice + 1}/{num_slices}'
        # Display grayscale background
        gray_img = axes[i].imshow(volume[:, :, current_slice], cmap='gray', alpha=1.0)
        img_displays.append(gray_img)
        # Overlay heatmap if provided
        if has_overlay:
            heatmap = axes[i].imshow(overlay[:, :, current_slice], cmap='viridis', alpha=0.5, norm=Normalize(vmin=overlay.min(), vmax=overlay.max()))
            img_displays.append(heatmap)
        axes[i].set_title(title)
        axes[i].axis('off')

    # Add colorbar if overlay is used
    if has_overlay:
        cbar = fig.colorbar(cm.ScalarMappable(norm=Normalize(vmin=overlay.min(), vmax=overlay.max()), cmap='viridis'), ax=axes, orientation='horizontal', fraction=0.03, pad=0.04)
        cbar.set_label("Overlay Intensity")

    # Function to handle keypress events for slice navigation
    def on_key(event):
        nonlocal current_slice
        if event.key == 'right':
            current_slice = (current_slice + 1) % num_slices  # Move to the next slice
        elif event.key == 'left':
            current_slice = (current_slice - 1) % num_slices  # Move to the previous slice
        # Update each subplot
        for i in range(num_channels):
            title = f'Channel {i + 1}, Slice {current_slice + 1}/{num_slices}' if is_4d else f'Slice {current_slice + 1}/{num_slices}'
            img_displays[i].set_data(volume[:, :, current_slice]) if not is_4d else img_displays[i].set_data(volume[:, :, current_slice, i])
            axes[i].set_title(title)
            if has_overlay:
                img_displays[i + 1].set_data(overlay[:, :, current_slice]) if not is_4d else img_displays[i + 1].set_data(overlay[:, :, current_slice, i])
        fig.canvas.draw()

    # Connect the keypress event to the handler
    fig.canvas.mpl_connect('key_press_event', on_key)
    plt.show()


# Path to your NIfTI file (adjust the path as necessary)
volume_path = 'C:/Users/jas1ek/nnUNet/inference_output/BRATS_002.nii.gz'
overlay_path = 'C:/Users/jas1ek/nnUNet/raw/Dataset001_BrainTumour/imagesTr/BRATS_002_0001.nii.gz'  # Optional overlay file

# Load the NIfTI files
volume_img = nib.load(volume_path)
volume_data = volume_img.get_fdata()

# Load the overlay if it exists
try:
    overlay_img = nib.load(overlay_path)
    overlay_data = overlay_img.get_fdata()
except FileNotFoundError:
    overlay_data = None

# Print the shape to understand the dimensions of the file
print(f"Volume shape: {volume_data.shape}")  # Expecting (X, Y, Z, Channels) or (X, Y, Z)
if overlay_data is not None:
    print(f"Overlay shape: {overlay_data.shape}")

# Display the interactive slices with grayscale + heatmap overlay
display_interactive_slices_multichannel(volume_data, overlay=overlay_data)
